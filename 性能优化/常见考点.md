### 性能优化怎么做的？
`1、网络传输优化`
- 压缩与精简：Gzip/Brotli 压缩、代码丑化、CSS/HTML 压缩。
- 减少请求数量：合并小文件、使用 CSS Sprites、图标字体。
- 缓存策略：HTTP 缓存（强缓存、协商缓存）、Service Worker 缓存。
- 使用 CDN：将内容分发到离用户更近的节点。
- HTTP/2 或 HTTP/3：利用多路复用、头部压缩等特性。

`2、资源加载优化`
- 预加载：`` 提前加载关键资源。
- 预连接：`` 提前与重要第三方源建立连接。
- 懒加载：图片、视频、非关键脚本的懒加载。
- 异步/延迟加载 JavaScript：使用 async 或 defer 属性。

`3、浏览器渲染优化`
- 关键 CSS：将首屏渲染所需的 CSS 内联到 HTML 的 `` 中。
- 避免 CSS @import：它会增加额外的网络往返。
- 优化 JavaScript 执行：避免长任务、使用 requestAnimationFrame 进行视觉变更。
- 减少重排和重绘：批量 DOM 操作、使用 class 切换而非直接修改样式。

`4、构建工具与代码层面优化`
- 代码分割：利用 Webpack、Vite 等工具的代码分割功能，按需加载。
- 摇树优化：移除未使用的代码。
- 框架优化：在 React/Vue 等框架中，合理使用 memo、useCallback 等避免不必要的渲染。

### FSP 的优化，这块可以细讲一下吗
### 优化完成之后的指标数据怎么样呢
#### 上面提到性能优化这块，你们有没有一些指标体去衡量你的页面，体系化的衡量你的页面做得好与不好，或者说怎么去改善的这些东西
#### 你们的标准是什么呢？什么是好，什么不好
#### FSP 衡量的周期是什么？
#### 你们会关注 INP 吗？
#### 前端的系统：全流程的监控，比如说项目要做一个大的重构，页面高可用你们是怎么保障的？比如说你们做了一个大的改变重构，xxx 的监控，页面上的高可用，你们怎么去保证？因为你这是核心页面，出问题会影响很大？


好的，前端性能优化中，网络请求部分的优化是重中之重，因为它直接影响到页面的首次加载速度（FP, FCP） 和用户体验。
下面我将从核心原则、具体技术手段、工具与监测三个层面，为你系统性地讲解如何优化网络请求。
一、核心优化原则
在深入具体技术之前，先理解几个核心原则，所有的优化手段都是围绕这些原则展开的：
减少请求数量：每个请求都有开销（DNS查询、TCP握手、TLS协商等），减少请求数是最直接的优化。
减小请求体积：传输的数据越少，加载自然越快。
加快请求速度：利用缓存、预连接、CDN等技术，让单个请求的响应更快。
优先关键请求：确保影响首屏内容的关键资源被优先加载。
并行请求与现代协议：利用浏览器特性和新协议，提高网络通道的效率。

二、具体技术手段与实践
1. 减少请求数量
- 资源合并：
CSS/JS 合并：将多个小文件合并成一个，减少HTTP请求数。虽然在 HTTP/2 多路复用的环境下收益变小，但在一些场景下仍有价值。
雪碧图（CSS Sprites）：将多个小图标合并到一张大图中，通过 background-position 来显示。适用于传统图标系统，但正逐渐被 SVG 和图标字体替代。

- 代码分割与懒加载：
代码分割（Code Splitting）：使用 Webpack、Vite 等打包工具，将代码按路由或组件拆分成多个 chunk，实现按需加载，避免首次加载全部JS。
图片/组件懒加载（Lazy Load）：对非首屏的图片或组件，只有当它们进入视口（viewport）时才开始加载。可以使用原生 loading="lazy" 属性或相关库实现。

- 避免不必要的重定向：每次重定向都会触发新的HTTP请求，增加RTT（往返延迟），应尽量减少或消除。

2. 减小请求体积
资源压缩：

Gzip/Brotli 压缩：务必在服务器上开启对文本资源（HTML, CSS, JS, JSON）的压缩。Brotli 算法比 Gzip 压缩率更高，是现代项目的首选。

图片优化：

选择合适的格式：WebP 格式在同等质量下体积远小于 PNG/JPG。对于不支持 WebP 的浏览器（如 Safari 旧版）可使用 <picture> 标签提供降级方案。

使用新格式：AVIF 格式比 WebP 压缩率更高，但兼容性稍差。

调整尺寸和质量：根据实际显示尺寸提供图片，避免“用大图显示小图”。

使用图片 CDN：自动进行格式转换、尺寸缩放和压缩。

代码精简：

Tree Shaking：通过 ES6 module 的静态分析，移除未被使用的代码（Dead Code）。

Minification：移除代码中的注释、空白符、缩短变量名，减小文件体积。Terser（用于JS）和 CSSNano（用于CSS）是常用工具。

优化第三方库：只引入需要的功能（例如 import { debounce } from 'lodash-es' 而不是引入整个 lodash）。评估第三方库的体积和必要性。

3. 加快请求速度
利用缓存：

强缓存：通过设置 Cache-Control 和 Expires 头，让浏览器直接从本地缓存读取资源，无需网络请求。适用于长期不变的静态资源（如打包后的 JS/CSS 文件，可设置较长缓存时间如一年）。

协商缓存：通过 ETag 或 Last-Modified 头，让浏览器询问服务器资源是否过期，未过期则返回 304 状态码，使用本地缓存。适用于频繁更新的资源。

使用 CDN（内容分发网络）：

将静态资源部署到全球各地的 CDN 节点，用户可以从地理上最近的节点获取资源，大幅降低网络延迟。

预连接与预解析：

dns-prefetch：提前解析第三方资源的域名。

preconnect：更进一步的优化，提前完成 DNS 查询、TCP 握手和 TLS 协商。

prefetch：提前加载未来可能用到的资源（如图片、JS）。

preload：以高优先级提前加载当前页面必定会用到的关键资源（如首屏字体、关键CSS）。

html
<!-- 预连接到重要的第三方源 -->
<link rel="preconnect" href="https://fonts.gstatic.com">
<!-- 预加载关键字体 -->
<link rel="preload" as="font" type="font/woff2" href="my-font.woff2" crossorigin>
升级 HTTP/2 或 HTTP/3：

HTTP/2：支持多路复用（一个TCP连接并行处理多个请求）、服务器推送、头部压缩等特性，能显著提升性能。

HTTP/3：基于 QUIC 协议，进一步解决了 TCP 的队头阻塞问题，连接建立更快，在弱网环境下表现更优。

4. 优化请求策略与API设计
避免阻塞渲染的请求：

将非关键的 CSS 和 JS 标记为异步加载。CSS 可以使用 media 属性，JS 使用 async 或 defer 属性。

API 聚合（BFF层）：

对于前端需要调用多个后端接口才能渲染一个页面的情况，可以在前端和后端之间加一个 BFF（Backend For Frontend） 层，由 BFF 聚合多个接口的数据，前端只需一次请求即可拿到所有数据。

GraphQL：

使用 GraphQL 替代传统的 RESTful API，前端可以精确地查询所需字段，避免“过度获取”数据，有效减小响应体积。

三、工具与监测
性能分析工具：

Chrome DevTools：Network 面板查看请求瀑布图；Lighthouse 或 Performance 面板进行全方位性能审计。

WebPageTest：提供更详细的网络级别分析和多地点测试。

真实用户监控（RUM）：

使用 Navigation Timing API 和 Resource Timing API 在线上真实环境中收集用户的性能数据，了解实际性能表现。

核心 Web 指标（Core Web Vitals）：

关注 LCP（最大内容绘制）、FID（首次输入延迟）、CLS（累积布局偏移）。优化网络请求对 LCP（如图片、字体加载）和 FID（JS执行时间）有直接影响。

总结与优先级建议
必做项：

开启 Gzip/Brotli 压缩。

设置合理的缓存策略（强缓存 for 静态资源）。

使用 CDN。

压缩和优化图片（转 WebP）。

代码分割与懒加载。

使用 preload 预加载关键资源。

强烈推荐：

升级到 HTTP/2。

使用 preconnect / dns-prefetch。

对 JS/CSS 进行 Tree Shaking 和 Minification。

优化第三方库。

架构优化：

引入 BFF 或 GraphQL 优化 API 调用。

考虑 HTTP/3。

性能优化是一个持续的过程，需要结合具体的业务场景和数据进行分析，确定瓶颈所在，然后有针对性地实施上述策略。从网络请求入手，通常是提升前端性能最有效的方式之一。

