#### 1 vue3响应式原理
步骤：
- 1、使用Proxy代理目标对象，拦截各种操作。
- 2、使用一个全局的WeakMap来存储目标对象和其依赖映射（depsMap）的关系。
- 3、在get操作中跟踪依赖（track），在set操作中触发更新（trigger）。
- 4、同样，我们实现一个effect函数，相当于Vue2的Watcher，用于执行副作用（如更新视图）。
#### 3、Vue 3.0在性能优化主要体现在哪

#### 4、vue3 的摇树优化是怎样的优化过程？

#### 5、watch和watchEffect异同
- watch：可以获取旧值、精确控制监听源、非立即执行
- watchEffect：简单副作用、自动依赖收集、立即执行逻辑
#### 6、Proxy中 Reflect 和 receiver
- Reflect 是一个内置对象，提供了拦截 JavaScript 操作的方法，它与 Proxy 陷阱一一对应，用于执行默认行为。
- receiver 是 Proxy 函数中的第三个参数，确保getter/setter中的this指向代理对象, 保持 this 上下文的正确性
`关键点： 总是使用 Reflect 方法并传递 receiver 参数，这样可以确保代理对象的行为与原始对象保持一致，特别是在涉及 this 绑定的场景中。`
```js
const obj = { x: 1, y: 2 };
// Reflect.get 返回属性值
console.log(Reflect.get(obj, 'x')); // 1
// Reflect.set 返回布尔值表示是否设置成功
console.log(Reflect.set(obj, 'z', 3)); // true
// Reflect.has 返回布尔值表示属性是否存在
console.log(Reflect.has(obj, 'x')); // true
// Reflect.deleteProperty 返回布尔值表示是否删除成功
console.log(Reflect.deleteProperty(obj, 'y')); // true
console.log(obj); // { x: 1, z: 3 }
```

#### 7、setup的几个注意点
#### 8、reactive 对比ref
 