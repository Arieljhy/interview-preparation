#### 1、Vue 3 组件间的通信
- Props: 自上而下传递数据。
- Emit: 自下而上报事件。
- v-model: 双向绑定。
- Provide/Inject: 跨层级传递数据。
- Expose/Ref: 暴露组件实例的方法和数据。
- Pinia/Vuex: 状态管理库。
- EventBus/Mitt: 全局事件总线。

#### 2、 vue3响应式原理
步骤：
- 1、使用Proxy代理目标对象，拦截各种操作。
- 2、使用一个全局的WeakMap来存储目标对象和其依赖映射（depsMap）的关系。
- 3、在get操作中跟踪依赖（track），在set操作中触发更新（trigger）。
- 4、同样，我们实现一个effect函数，相当于Vue2的Watcher，用于执行副作用（如更新视图）。

#### 3、Vue 3.0在性能优化主要体现在哪
`响应式系统优化：`
使用es6的新特性 proxy，对对象 数组整体代理，不用遍历每个对象的所有属性，性能更好
`编译阶段优化：`
- 静态提升：在编译阶段会识别静态节点并提升到渲染函数外部，次重渲染时会被复用，避免不必要的创建和比较
- Patch Flags 标志：在编译阶段为动态节点添加标记，标识需要更新的内容类型；运行时只需检查这些标记，避免全量比较
- Diff 算法优化：
  - Vue 3 采用双端比较 + 最长递增子序列的算法，找出需要移动的最小次数
- 事件缓存：针对元素绑定的监听事件进行缓存，避免不必要的组件渲染
`打包优化`：
使用tree-shaking，去掉未使用的代码和注释，减少打包体积

#### 4、vue3 的摇树优化是怎样的优化过程？
静态编译优化，利用es module 的
#### 5、watch和watchEffect异同
- watch：可以获取旧值、精确控制监听源、非立即执行
- watchEffect：简单副作用、自动依赖收集、立即执行逻辑

#### 6、Proxy中 Reflect 和 receiver
- Reflect 是一个内置对象，提供了拦截 JavaScript 操作的方法，它与 Proxy 陷阱一一对应，用于执行默认行为。
- receiver 是 Proxy 函数中的第三个参数，确保getter/setter中的this指向代理对象, 保持 this 上下文的正确性
`关键点： 总是使用 Reflect 方法并传递 receiver 参数，这样可以确保代理对象的行为与原始对象保持一致，特别是在涉及 this 绑定的场景中。`
```js
const obj = { x: 1, y: 2 };
// Reflect.get 返回属性值
console.log(Reflect.get(obj, 'x')); // 1
// Reflect.set 返回布尔值表示是否设置成功
console.log(Reflect.set(obj, 'z', 3)); // true
// Reflect.has 返回布尔值表示属性是否存在
console.log(Reflect.has(obj, 'x')); // true
// Reflect.deleteProperty 返回布尔值表示是否删除成功
console.log(Reflect.deleteProperty(obj, 'y')); // true
console.log(obj); // { x: 1, z: 3 }
```

#### 7、setup的几个注意点

#### 8、reactive 对比ref
- 数据类型：ref声明基础类型 和 对象、数组都可以，reactive只能声明对象、数组；
- ref 需要通过 .value 去 访问 和 设置值，reactive 不需要
- ref 声明的值 通过.value重新赋值之后，仍然保持响应式，reactive 声明的值 会失去响应式

#### 9、响应式丢失
- reactive 声明的对象数据，直接解构会失去响应式，需要使用 toRefs() 处理后再解构使用
- pinia 声明的store在组件 中直接解构使用时，需要使用 storeToRefs() 处理后再解构使用
 